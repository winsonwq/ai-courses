# L12 多 Agent 架构和分层 Subagent 架构：从"扁平协作"到"层级掌控"

https://github.com/user-attachments/assets/098f1a2b-c3d0-43f0-8f0f-75b257501800

在本课中，我们将从 L11 的**扁平多 Agent 协作**（Coordinator + Workers）演进到**分层 Subagent 架构**（Hierarchical Subagents），探讨为什么需要多层结构，以及如何根据**上下文掌控性**来科学地划分 Agent。

---

## 1. L11 架构的局限性：扁平结构的瓶颈

L11 采用了经典的 "协调者 + 专家" 扁平架构，但在面对**超复杂任务**时会遇到瓶颈：

| 维度 | L11 扁平架构 | 遇到的问题 |
| :--- | :--- | :--- |
| **任务委派** | 协调者直接委派给一线专家 | 协调者需要了解所有专家的细节，Prompt 变得臃肿 |
| **上下文管理** | 所有上下文流向协调者 | 协调者成为"信息瓶颈"，处理能力有限 |
| **错误传播** | 任何一个专家失败，整个流程失败 | 缺乏层级化的错误处理和恢复机制 |
| **扩展性** | 新增专家只需注册到协调者 | 但协调者的决策逻辑复杂度 O(n) 线性增长 |

**真实场景案例**：用户要求 *"分析过去一年我的 ~/documents 中所有代码项目，生成技术债务报告，并按严重程度排序，最后发邮件给团队。"*

这个任务涉及：
1. 文件扫描（找出所有代码项目）
2. 代码分析（识别技术债务）
3. 严重程度评估（需要专业知识）
4. 报告生成
5. 邮件发送

如果用 L11 的扁平架构，协调者需要同时知道"如何扫描文件"、"如何分析代码"、"如何评估严重程度"、"如何生成报告"、"如何发送邮件"——这违反了**单一职责原则**，协调者的 System Message 会膨胀到无法维护。

---

## 2. 分层 Subagent 架构：核心思想

### 2.1 层级划分原则：**上下文掌控性**

划分 Agent 的准则不是"模拟现实生活中的分工"，而是**根据对上下文的掌控性**来划分：

| 层级 | 名称 | 掌控的上下文 | 职责 |
| :--- | :--- | :--- | :--- |
| **L0** | 顶层协调者 | 用户意图、全局目标 | 理解需求，分解为高层任务流 |
| **L1** | 领域主管 | 特定领域内的完整上下文 | 管理该领域的子任务序列 |
| **L2** | 技能执行者 | 单一工具/技能的执行上下文 | 执行具体操作 |

**关键洞察**：每个层级的 Agent 只关心它**能理解和掌控**的上下文范围。

### 2.2 为什么需要多层结构？

```
┌─────────────────────────────────────────────────────────────┐
│                    用户请求                                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  L0 顶层协调者 (Coordinator)                                  │
│  - 理解用户意图                                               │
│  - 分解为高层任务流：分析 → 评估 → 报告 → 发送                   │
│  - 不关心具体实现细节                                          │
└─────────────────────────────────────────────────────────────┘
            │               │               │
            ▼               ▼               ▼
┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
│  L1 项目分析主管  │ │  L1 评估主管     │ │  L1 报告生成主管  │
│  - 管理文件扫描   │ │  - 汇总分析结果  │ │  - 组织报告内容   │
│  - 管理代码分析   │ │  - 执行严重评估  │ │  - 生成 Markdown │
│  - 汇总项目清单   │ │  - 排序技术债务  │ │  - 触发邮件发送   │
└──────────────────┘ └──────────────────┘ └──────────────────┘
            │               │
            ▼               ▼
┌──────────────────┐ ┌──────────────────┐
│  L2 技能执行者    │ │  L2 技能执行者    │
│  - 文件扫描工具   │ │  - 严重程度评估   │
│  - 代码分析工具   │ │  - 排序算法       │
└──────────────────┘ └──────────────────┘
```

**核心差别辨析**：

*   **L11 (2层架构：协调者 + Agents)**：
    *   **结构**：`Coordinator -> Worker Agent (with Tools)`
    *   **协调者职责**：负责任务分发。它**不直接调用底层工具**（如 `runShell`），而是调用 `delegate` 具将任务转交给 Worker。
    *   **局限**：协调者虽然不干脏活，但这导致它必须管理**所有** Worker 的调度逻辑。如果任务链很长（例如：先扫描 -> 再分析 -> 再过滤 -> 再总结），协调者需要记住每一步的状态，导致 Context 极其臃肿。

*   **L12 (3层架构：协调者 + Manager Agents + Subagents)**：
    *   **结构**：`Coordinator -> Manager Agent -> Subagent (with Tools)`
    *   **引入 Manager 层**：这一层的核心作用是**分担流程管理压力**。
        *   **Coordinator** 只管：“把‘技术报告’这件事交给‘分析主管’”。
        *   **Manager** 负责：“扫描 -> 分析 -> 汇总”这个具体的执行流。
        *   **Subagent** 负责：具体执行 `find` 命令或 `cloc` 工具。
    *   **Subagent 职责定义**：
        *   **原子性**：只做一件事（如“查找文件”），不关心流程（不关心“查找后要干嘛”）。
        *   **无状态**：执行完即销毁，不保留长对话历史。
        *   **工具容器**：本质上是“智能化的工具箱”。它可以自己修正参数错误，但没有复杂规划能力。

**为什么这个区别很重要？**
在 L11 中，协调者既是 CEO 又是项目经理，而在 L12 中，引入了“部门经理” (Manager)，让 CEO (Coordinator) 可以专注于战略，让员工 (Subagent) 专注于执行。

**对比扁平架构**：
- **L11 扁平**：Coordinator 直接管理 N 个 Worker。随着 N 增加，Coordinator 的逻辑复杂度爆炸。
- **L12 分层**：Coordinator 只管理 M 个 Manager。每个 Manager 再管理 K 个 Subagent。复杂度被分摊。


### 2.3 深度思考：为什么 L2 “扫地僧”也需要是 Agent？

这是一个非常关键的设计直觉：**为什么一个简单的“搜索目录”或“分析文件”不直接做成一个 Tool，而要封装成一个 Subagent？**

**核心逻辑：因为它需要具备“自我纠错”的闭环循环（Mini-loop）。**

*   **Tool (单纯的工具)**：是一次性的执行。如果参数错了（比如目录路径写错），或者结果不符合预期（比如搜索结果太多超出了 Context 限制），工具只会报错或返回垃圾数据。这时，**错误处理的压力会直接甩给上层的 Manager**，导致 Manager 的 Prompt 变得极其臃肿（充斥着各种 `if error then...` 的逻辑）。
*   **Subagent (带脑子的工具箱)**：是一个具备 Task -> Observation -> Thought -> Action 的微型循环。
    *   **例子**：搜索目录。
        *   **Action**：运行 `ls`。
        *   **Observation**：发现结果有 5000 行，太乱了。
        *   **Thought**（关键）：*“结果太多，上司可能不需要这么多信息。我应该尝试用 `grep` 过滤一下关键字再上报。”*
        *   **Action**：再次运行过滤命令。
        *   **Final Output**：返回精简后的有用结果。

**结论**：将职责单一化并封装成 Agent 的必要性在于：**它在执行单一职责时能自我消化底层的琐碎错误和异常**。这种“内部闭环”将复杂性完美地隔离在底层，让上层架构（L0, L1）始终保持极高的清晰度和确定性。

---

## 3. 划分准则是"上下文掌控性"而非"现实分工"

### 3.1 错误的划分方式（模拟现实生活）

| 现实角色 | 对应 Agent | 问题 |
| :--- | :--- | :--- |
| 产品经理 | 需求分析 Agent | 产品经理不写代码，不需要代码上下文 |
| 程序员 | 编码 Agent | 程序员不直接和用户沟通，缺乏用户意图上下文 |
| 测试工程师 | 测试 Agent | 测试只关注结果，不关注实现过程 |

这种划分的问题是：**Agent 的上下文是离散的、断裂的**。

### 3.2 正确的划分方式（基于上下文掌控性）

```
任务：分析代码项目技术债务

错误划分（按现实角色）：
  需求分析 Agent → 编码 Agent → 测试 Agent
  问题：编码 Agent 不需要知道"用户想要技术债务报告"这个需求

正确划分（按上下文掌控性）：
  ┌─────────────────────────────────────────┐
  │  顶层协调者                              │
  │  掌控：用户意图 + 全局目标                │
  │  知道："用户想要技术债务报告"             │
  └─────────────────────────────────────────┘
                    │
                    ▼
  ┌─────────────────────────────────────────┐
  │  代码分析主管                            │
  │  掌控：代码库上下文 + 技术债务规则         │
  │  知道："这个文件有 N 个技术债务问题"       │
  │  不知道："用户是谁"或"报告发给谁"          │
  └─────────────────────────────────────────┘
                    │
                    ▼
  ┌─────────────────────────────────────────┐
  │  文件扫描执行者                          │
  │  掌控：文件系统上下文                     │
  │  知道："~/projects 下有 10 个代码项目"    │
  │  不知道："为什么需要扫描"                 │
  └─────────────────────────────────────────┘
```

**核心原则**：
1. **向上看**：每个 Agent 知道"为什么做"（更高层的意图）
2. **向下看**：每个 Agent 知道"怎么做"（更低层的实现）
3. **横向看**：同层 Agent 之间不直接通信，通过父节点协调

---

## 4. 架构模式：Hierarchical Delegation

### 4.1 递归委派模型

```typescript
interface HierarchicalAgent {
  // 委派给子 Agent（向下）
  delegateToChild(childId: string, task: string): Promise<SubAgentResult>;
  
  // 返回结果给父 Agent（向上）
  reportToParent(result: string): Promise<Parent指令>;
}
```

### 4.2 三层 Delegation 流程

```
用户请求
    │
    ▼
┌─────────────────────────────────────────────────┐
│  L0: 顶层协调者 (Root Coordinator)               │
│  System: "你是项目技术债务分析系统的总控"           │
│                                                │
│  思考：                                        │
│  1. 需要先分析代码库                             │
│  2. 需要评估严重程度                             │
│  3. 需要生成报告                                 │
│  4. 需要发送邮件                                 │
│                                                │
│  委派：delegateToAnalysisManager("执行完整分析")  │
└─────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────┐
│  L1: 分析主管 (Analysis Manager)                 │
│  System: "你是代码分析主管，负责管理分析流程"      │
│                                                │
│  掌控的上下文：                                  │
│  - 需要扫描 ~/documents 下所有项目                │
│  - 需要对每个项目运行代码分析                     │
│  - 需要汇总所有分析结果                           │
│                                                │
│  委派模式：                                      │
│  for each 项目:                                 │
│    delegateToProjectScanner(projectPath)        │
│  然后:                                          │
│    delegateToCodeAnalyzer(汇总结果)             │
└─────────────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        ▼           ▼           ▼
┌───────────┐ ┌───────────┐ ┌───────────┐
│ L2 文件   │ │ L2 代码   │ │ L2 代码   │
│ 扫描执行者 │ │ 分析执行者 │ │ 分析执行者 │
│ ...       │ │ ...       │ │ ...       │
└───────────┘ └───────────┘ └───────────┘
```

### 4.3 关键优势

| 优势 | 说明 |
| :--- | :--- |
| **上下文隔离** | L2 执行者不需要知道"为什么要扫描这个目录"，只知道"扫描这个目录" |
| **可组合性** | 分析主管可以被其他流程复用（如安全审计、代码质量检查） |
| **错误局部化** | 如果某个项目分析失败，分析主管可以决定重试、跳过或上报 |
| **性能优化** | 可以并行调用多个 L2 执行者（文件扫描 + 代码分析） |

---

## 5. Demo 展示：技术债务分析系统

**用户需求**：*"分析 ~/projects 目录下所有 React 项目，生成技术债务报告，按严重程度排序。"*

### 完整执行流程追踪

```
User: 分析 ~/projects 目录下所有 React 项目，生成技术债务报告

[Root Coordinator]
AI: 收到！我将启动技术债务分析流程。
    第一步：让分析主管扫描项目并分析代码...
Tool: delegateToAnalysisManager({
  "task": "分析 ~/projects 下所有 React 项目，识别技术债务",
  "options": {"parallel": true}
})

    [Analysis Manager]
    AI: 开始分析流程...
    1. 扫描 ~/projects 目录下的 React 项目...
Tool: delegateToProjectScanner({
  "directory": "~/projects",
  "filter": "package.json 包含 react"
})

        [Project Scanner (L2)]
        AI: 扫描 ~/projects...
Tool: runShell({"command": "find ~/projects -name 'package.json' -exec grep -l react {} \\;"})
        AI: 发现 5 个 React 项目 [STOP]
    
    2. 对每个项目进行代码分析...
    （并行调用 5 个代码分析执行者）
Tool: delegateToCodeAnalyzer({"project": "~/projects/web-app-1", "focus": "tech-debt"})
Tool: delegateToCodeAnalyzer({"project": "~/projects/web-app-2", "focus": "tech-debt"})
...

        [Code Analyzer 1 (L2)]
        AI: 分析 ~/projects/web-app-1...
Tool: runShell({"command": "cloc --report-type=javascript"})
Tool: runShell({"command": "find src -name '*.js' -exec wc -l {} + | tail -1"})
        AI: 发现 12 个技术债务问题：高危 3、中危 5、低危 4 [STOP]
    
    ... (其他 4 个项目的分析结果)

    3. 汇总并评估严重程度...
Tool: delegateToSeverityAssessor({
  "projects": [
    {"name": "web-app-1", "issues": 12, "high": 3},
    {"name": "web-app-2", "issues": 8, "high": 2},
    ...
  ]
})

        [Severity Assessor (L2)]
        AI: 评估严重程度...
        AI: 综合评估完成，按严重程度排序：
            1. web-app-1 (高危 3，中危 5)
            2. web-app-2 (高危 2，中危 4)
            ... [STOP]
    
    AI: 分析完成！现在生成报告...
Tool: delegateToReportGenerator({
  "title": "技术债务分析报告",
  "findings": [...],
  "sortBy": "severity"
})

    [Report Generator (L2)]
    AI: 生成 Markdown 报告...
    AI: ## 技术债务分析报告\n\n### 执行摘要\n... [STOP]

AI: 分析完成！以下是技术债务报告：
...
```

---

## 6. 运行方式

### 环境配置
在项目根目录或本目录下创建 `.env` 文件，配置 API Key：
```bash
DEEPSEEK_API_KEY=your_api_key_here
```

### 安装与启动
```bash
cd "L12 多 Agent 架构和分层 subagent 架构"
npm install
npm run dev
```

### 尝试这些指令：
- "分析 ~/projects 目录下所有代码项目，生成技术债务报告"
- "扫描 ~/documents 下所有 PDF 文件，提取关键信息并生成摘要"
- "检查 ~/code 中所有 API 接口，生成安全评估报告"

---

## 7. 代码结构速览

```
L12 多 Agent 架构和分层 subagent 架构/
├── src/
│   ├── index.ts                    # 入口 + 顶层协调者定义
│   ├── agents/
│   │   ├── types.ts                # Agent 类型定义（支持层级）
│   │   ├── registry.ts             # Agent 注册表（支持层级查找）
│   │   ├── coordinator.ts          # 顶层协调者（Root Coordinator）
│   │   ├── manager/
│   │   │   ├── analysis.ts         # L1 分析主管
│   │   │   └── assessment.ts       # L1 评估主管
│   │   └── worker/
│   │       ├── scanner.ts          # L2 文件扫描执行者
│   │       ├── analyzer.ts         # L2 代码分析执行者
│   │       ├── assessor.ts         # L2 严重程度评估执行者
│   │       └── reporter.ts         # L2 报告生成执行者
│   ├── tools/
│   │   ├── executor.ts             # 工具执行器（支持递归）
│   │   ├── shell.ts                # Shell 工具
│   │   └── ...
│   └── llm/
│       ├── client.ts               # LLM 调用
│       └── types.ts
├── package.json
└── tsconfig.json
```

---

## 8. L11 vs L12：架构对比

| 特性 | L11 扁平架构 | L12 分层架构 |
| :--- | :--- | :--- |
| **层级深度** | 2 层（Coordinator → Worker） | 3+ 层（Coordinator → Manager → Worker） |
| **Agent 数量** | 少（2-5 个专家） | 多（支持数十个执行者） |
| **上下文管理** | 集中在协调者 | 分布式管理 |
| **适用场景** | 简单任务委派 | 超复杂任务流 |
| **扩展方式** | 新增 Worker | 新增 Manager 层级 |
| **复杂度** | O(n) | O(log n) |

---

## 9. 何时选择分层架构？

### 选择 L11 扁平架构当：
- 任务可以被清晰分解为 2-5 个独立的子任务
- 子任务之间相互独立，不需要复杂的协调逻辑
- 协调者可以轻松理解和决策委派

### 选择 L12 分层架构当：
- 任务需要 5+ 个子任务，且子任务有明显的分组
- 子任务之间有依赖关系，需要顺序或条件执行
- 需要并行处理大量相似任务
- 需要专业化的上下文管理和错误处理

> **经验法则**：如果你的协调者 System Message 超过 500 字，考虑引入分层架构。
